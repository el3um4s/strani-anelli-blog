---
title: "How To Implement Brute Force Attacks on Hash Values in JavaScript"
published: true
usa_webp: true
header:
  immagine_tipo: "jpg"
  miniatura: "image"
  immagine_estesa: "image"
  immagine_fonte: "Photo credit: [**Ludovic Toinel**](https://unsplash.com/@ltoinel)"
  overlay_filter: rgba(79, 79, 79, 0.5)
date: "2021-12-18 20:00"
categories:
  - dev advent
  - javascript
tags:
  - dev advent
  - javascript
---

I taught the elves how to [create passwords with JavaScript](https://javascript.plainenglish.io/how-to-generate-a-random-password-using-javascript-cbeb4b72ec12) and they lost the password. This is a problem, because the central elven computer system does not keep copies of passwords. It simply stores the hash, which by its nature is practically impossible to decode. What can I do?

### The Puzzle: Decoding The Code üîê

{% include picture img="cover.webp" ext="jpg" alt="" %}

[Dev Advent Calendar puzzle 17 üéÖ](https://github.com/devadvent/puzzle-17) can be summed up like this: How to hack a password using JavaScript? How to [bruteforce](https://en.wikipedia.org/wiki/Brute-force_search) a hash table?

Obviously the problem is unsolvable. The hash cryptographic functions are inviolable. Before tackling the problem it is better to understand what is meant by a hash function

### Cryptographic hash function

[Wikipedia](https://en.wikipedia.org/wiki/Cryptographic_hash_function) explains well what the characteristics are.

How does it work? A hash function takes data and converts it to a fixed-size binary string. Each dataset produces a different hash. And similar data produces very different hashes.

These algorithms are designed to resist various types of attacks and have 3 levels of security:

- **Pre-image resistance**: Given a hash value h, it should be difficult to find any message m such that h = hash(m). This concept is related to that of a one-way function. Functions that lack this property are vulnerable to preimage attacks.
- **Second pre-image resistance**: Given an input m1, it should be difficult to find a different input m2 such that hash(m1) = hash(m2). This property is sometimes referred to as weak collision resistance. Functions that lack this property are vulnerable to second-preimage attacks.
- **Collision resistance**: It should be difficult to find two different messages m1 and m2 such that hash(m1) = hash(m2). Such a pair is called a cryptographic hash collision. This property is sometimes referred to as strong collision resistance. It requires a hash value at least twice as long as that required for pre-image resistance; otherwise collisions may be found by a birthday attack.

This allows you to be sure that if two hashes are identical then the starting data are the same.

An example of use are passwords. If we want to create an identity verification system, it is dangerous to create a database with the passwords of the various users. It is advisable to keep only the hash of the passwords. When someone tries to log in, we compare the hash generated by the request with the saved hash: if they are identical then the password is correct.

This thing fascinates me. Being able to verify the correctness of a password without having to know it. Another feature fascinates me a lot: two similar passwords have very different hashes.

<script src="https://gist.github.com/el3um4s/0bd50f2a455b23006c2ce224790299b2.js"></script>

This makes it very difficult to trace the starting password.

### Calculate the Hash of a¬†password

To make the problem manageable it is necessary to simplify. The rules of engagement are these:

- we know the hash of the password to find
- we know what form the starting password had: `<UPPER CASE LETTER>-<3-DIGIT-NUMBER>`. For example `X-348`, `L-239`, `V-111`.

This is a great help. We can create a list of potential passwords to test. Then we calculate the hash of each one until we find the correct one.

In NodeJS it is easy to find the hash of a string. Just use the [crypto](https://nodejs.org/api/crypto.html) API:

<script src="https://gist.github.com/el3um4s/ae5a155c306bbf28d2d149ac266c20b1.js"></script>

### Create a list of potential passwords

The simplest way to create a list of potential passwords to test is to use two nested `for` loops. I use the first one to scroll through the letters of the alphabet:

<script src="https://gist.github.com/el3um4s/989c306978526c11ba0229b59bcdbc01.js"></script>

I then insert a second loop to iterate through all numbers from `0` to `999`

<script src="https://gist.github.com/el3um4s/5b21386bddd2fdf17cb998e0e343958f.js"></script>

So I create a `test` variable:

<script src="https://gist.github.com/el3um4s/0b6727fd83dc80b9bc156f3b705575df.js"></script>

I use the [String.prototype.padStart()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart) method to make each password have exactly 3 numbers. This way I can transform `A-0` to `A-000`, `C-12` to `C-012` and so on.

I get the hash

<script src="https://gist.github.com/el3um4s/dc99dc5a8df19279885ecb30de0a6b99.js"></script>

Finally I compare it with what I already have:

<script src="https://gist.github.com/el3um4s/f0a17e08f8152509a1bc9b0c62fd2622.js"></script>

I quit the function immediately: I don't need to check the other passwords. Once I found the one generating the correct hash I also found what I was looking for.

The complete code looks like this:

<script src="https://gist.github.com/el3um4s/e8d407116bb6f9f301e57d83715ae831.js"></script>

### To Refractor

It is a simple and understandable solution. But I can do better. I can delete the `nested loop`. I can also delete one of the two `returns`. This way I can get something clearer:

<script src="https://gist.github.com/el3um4s/73c9fe72aa646601fd6963b8bb3bd404.js"></script>

Actually you could simplify it even more by adding the `listPassword` argument instead of calculating it inside the function. But the puzzle doesn't allow me to do that.

I have decided to extract from the `bruteForcePassword` function everything that is not related to the problem: the creation of the password list and the comparison of the hashes:

<script src="https://gist.github.com/el3um4s/f4b447c63a20333d80754fb470371cdb.js"></script>

The `isPassword` function returns the password directly and not a boolean value. This way I can take advantage of JavaScript's ability to treat strings as [truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy) and null values as [falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy). I need it to simplify the exit from the `for...of` loop.

To generate the password list, I break down the problem into several parts. First I need an array containing the numbers `0` to `999`. I create this function:

<script src="https://gist.github.com/el3um4s/fa1e27b4c97da891da07a5bd2acd09d3.js"></script>

There is a good discussion on [stackoverflow](https://stackoverflow.com/questions/3746725/how-to-create-an-array-containing-1-n) on this problem. In short, I can create an array of `n` elements with `Array(n)`. If I add the [Array.prototype.keys()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys) method and then use the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax), I can get an array of `n` elements each of which contains a number that represents the index of its position:

<script src="https://gist.github.com/el3um4s/b923770dfe6ce17aa7f65a7c6cc326ad.js"></script>

I use this array with the[Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) method to add the missing 0s to the first 100 elements.

I can easily create an array containing the letters of the alphabet:

<script src="https://gist.github.com/el3um4s/adff749ca4dd3eefcbb210130bc8aa49.js"></script>

This time I don't use `keys()`: I can leave all the elements of the array null and then use the index to get the `charCode` of the letter I want to insert.

I create a helper function to join letters and numbers:

<script src="https://gist.github.com/el3um4s/cfa90cc8adf02a3636706b9d389faa53.js"></script>

I add the desired character to each element of the array with numbers. Finally I create the list of potential passwords:

<script src="https://gist.github.com/el3um4s/374bcb1f55c2671a19bcd538b84b2147.js"></script>

By combining everything I get my solution:

<script src="https://gist.github.com/el3um4s/1789e92cf0d57d4ad8166167a5d810c6.js"></script>

That's all. This puzzle is related to the number 11:

- [How to Generate a Random Password Using JavaScript](https://javascript.plainenglish.io/how-to-generate-a-random-password-using-javascript-cbeb4b72ec12)

I have saved in this list the solutions to the other problems of this challenge:

- [Dev Advent Calendar](https://el3um4s.medium.com/list/dev-advent-calendar-89d163132d6e)
